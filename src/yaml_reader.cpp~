#include "yaml_reader.hpp"
#include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
#include "duckdb/common/file_system.hpp"
#include "duckdb/function/table_function.hpp"
#include "duckdb/parser/parsed_data/create_table_function_info.hpp"
#include "duckdb/common/string_util.hpp"
#include "duckdb/main/extension_util.hpp"

namespace duckdb {

// Bind data structure for read_yaml
struct YAMLReadRowsBindData : public TableFunctionData {
    YAMLReadRowsBindData(Value file_path, YAMLReader::YAMLReadOptions options) 
        : file_path(std::move(file_path)), options(options) {}

    Value file_path;  // Store the original file path value (string or list)
    YAMLReader::YAMLReadOptions options;
    vector<YAML::Node> yaml_docs;  // Each document in the YAML file
    vector<string> names;          // Column names
    vector<LogicalType> types;     // Column types
    idx_t current_doc = 0;         // Current document being processed
};


// Bind data structure for read_yaml_objects
struct YAMLReadBindData : public TableFunctionData {
    YAMLReadBindData(Value file_path, YAMLReader::YAMLReadOptions options) 
        : file_path(std::move(file_path)), options(options) {}

    Value file_path;  // Store the original file path value
    YAMLReader::YAMLReadOptions options;
    vector<YAML::Node> yaml_docs;
    vector<string> names;
    vector<LogicalType> types;
    idx_t current_row = 0;
};

// YAML Type Conversions
LogicalType YAMLReader::DetectYAMLType(YAML::Node node) {
    if (!node) {
        return LogicalType::VARCHAR;
    }

    switch (node.Type()) {
        case YAML::NodeType::Scalar: {
            std::string scalar_value = node.Scalar();

            // Basic type detection
            if (scalar_value == "true" || scalar_value == "false" || 
                scalar_value == "yes" || scalar_value == "no") {
                return LogicalType::BOOLEAN;
            }

            try {
                // Try integer
                size_t pos;
                std::stoll(scalar_value, &pos);
                if (pos == scalar_value.size()) {
                    return LogicalType::BIGINT;
                }

                // Try double
                std::stod(scalar_value, &pos);
                if (pos == scalar_value.size()) {
                    return LogicalType::DOUBLE;
                }
            } catch (...) {
                // Not a number
            }

            return LogicalType::VARCHAR;
        }
        case YAML::NodeType::Sequence: {
            if (node.size() == 0) {
                return LogicalType::LIST(LogicalType::VARCHAR);
            }

            // Check first element to determine list type
            YAML::Node first_element = node[0];
            LogicalType element_type = DetectYAMLType(first_element);

            // If the sequence contains maps, they should be a list of structs
            if (first_element.IsMap()) {
                // The element_type will already be a struct type from the recursive call
            }

            return LogicalType::LIST(element_type);
        }
        case YAML::NodeType::Map: {
            child_list_t<LogicalType> struct_children;
            for (auto it = node.begin(); it != node.end(); ++it) {
                std::string key = it->first.Scalar();
                LogicalType value_type = DetectYAMLType(it->second);
                struct_children.push_back(make_pair(key, value_type));
            }
            return LogicalType::STRUCT(struct_children);
        }
        default:
            return LogicalType::VARCHAR;
    }
}

Value YAMLReader::YAMLNodeToValue(YAML::Node node, LogicalType target_type) {
    if (!node) {
        return Value(target_type); // NULL value
    }

    // Handle based on YAML node type
    switch (node.Type()) {
        case YAML::NodeType::Scalar: {
            std::string scalar_value = node.Scalar();

            if (target_type.id() == LogicalTypeId::VARCHAR) {
                return Value(scalar_value);
            } else if (target_type.id() == LogicalTypeId::BOOLEAN) {
                if (scalar_value == "true" || scalar_value == "yes" || scalar_value == "on") {
                    return Value::BOOLEAN(true);
                } else if (scalar_value == "false" || scalar_value == "no" || scalar_value == "off") {
                    return Value::BOOLEAN(false);
                }
                return Value(target_type); // NULL if not valid boolean
            } else if (target_type.id() == LogicalTypeId::BIGINT) {
                try {
                    return Value::BIGINT(std::stoll(scalar_value));
                } catch (...) {
                    return Value(target_type); // NULL if conversion fails
                }
            } else if (target_type.id() == LogicalTypeId::DOUBLE) {
                try {
                    return Value::DOUBLE(std::stod(scalar_value));
                } catch (...) {
                    return Value(target_type); // NULL if conversion fails
                }
            }
            return Value(scalar_value); // Default to string
        }
        case YAML::NodeType::Sequence: {
            if (target_type.id() != LogicalTypeId::LIST) {
                return Value(target_type); // NULL if not expecting a list
            }

            // Get child type for list
            auto child_type = ListType::GetChildType(target_type);

            // Create list of values - recursively convert each element
            vector<Value> values;
            for (size_t i = 0; i < node.size(); i++) {
                values.push_back(YAMLNodeToValue(node[i], child_type));
            }

            return Value::LIST(values);
        }
        case YAML::NodeType::Map: {
            if (target_type.id() != LogicalTypeId::STRUCT) {
                return Value(target_type); // NULL if not expecting a struct
            }

            // Get struct children
            auto &struct_children = StructType::GetChildTypes(target_type);

            // Create struct values
            child_list_t<Value> struct_values;
            for (auto &entry : struct_children) {
                if (node[entry.first]) {
                    struct_values.push_back(make_pair(
                        entry.first, 
                        YAMLNodeToValue(node[entry.first], entry.second)
                    ));
                } else {
                    struct_values.push_back(make_pair(
                        entry.first, 
                        Value(entry.second) // NULL value
                    ));
                }
            }

            return Value::STRUCT(struct_values);
        }
        default:
            return Value(target_type); // NULL for unknown type
    }
}

// Helper function to parse multi-document YAML with error recovery
vector<YAML::Node> YAMLReader::ParseMultiDocumentYAML(const char* yaml_content, bool ignore_errors) {
    std::stringstream yaml_stream(yaml_content);
    
    vector<YAML::Node> valid_docs;
    try {
        valid_docs = YAML::LoadAll(yaml_stream);
        return valid_docs;
    } catch (const YAML::Exception &e) {
        if (!ignore_errors) {
            throw IOException("Error parsing YAML file: " + string(e.what()));
        }
        
        // On error with ignore_errors=true, try to recover partial documents
        return RecoverPartialYAMLDocuments(yaml_content);
    }
}

// Helper function to recover partial valid documents from YAML with syntax errors
vector<YAML::Node> YAMLReader::RecoverPartialYAMLDocuments(const char* yaml_content) {
    vector<YAML::Node> valid_docs;
    std::string yaml_str = yaml_content;
    
    // Split the content by document markers
    std::vector<std::string> doc_strings;
    size_t pos = 0;
    size_t prev = 0;
    
    // Handle first document if it doesn't start with '---'
    if (yaml_str.find("---") != 0) {
        pos = yaml_str.find("\n---");
        if (pos != std::string::npos) {
            doc_strings.push_back(yaml_str.substr(0, pos));
            prev = pos + 1;
        }
    }
    
    // Find all document markers
    while ((pos = yaml_str.find("\n---", prev)) != std::string::npos) {
        size_t end = yaml_str.find("\n---", pos + 4);
        if (end == std::string::npos) {
            doc_strings.push_back(yaml_str.substr(pos + 1));
            break;
        }
        doc_strings.push_back(yaml_str.substr(pos + 1, end - pos - 1));
        prev = end + 1;
    }
    
    // Add the last document if not already added
    if (prev < yaml_str.length() && doc_strings.empty()) {
        doc_strings.push_back(yaml_str);
    }
    
    // Try to parse each document individually
    for (const auto& doc_str : doc_strings) {
        try {
            YAML::Node doc = YAML::Load(doc_str);
            valid_docs.push_back(doc);
        } catch (const YAML::Exception &) {
            // Skip invalid documents
        }
    }
    
    return valid_docs;
}

// Helper function to extract row nodes from YAML documents
vector<YAML::Node> YAMLReader::ExtractRowNodes(const vector<YAML::Node>& docs, bool expand_root_sequence) {
    vector<YAML::Node> row_nodes;
    
    for (auto &doc : docs) {
        if (doc.IsSequence() && expand_root_sequence) {
            // Each item in the sequence becomes a row
            for (size_t i = 0; i < doc.size(); i++) {
                if (doc[i].IsMap()) { // Only add map nodes as rows
                    row_nodes.push_back(doc[i]);
                }
            }
        } else if (doc.IsMap()) {
            // Document itself becomes a row
            row_nodes.push_back(doc);
        }
    }
    
    return row_nodes;
}

// Helper function to get files to process from path value (string or list)
vector<string> YAMLReader::GetFilesToProcess(ClientContext &context, const Value &path_value, bool recursive) {
    auto &fs = FileSystem::GetFileSystem(context);
    vector<string> result;
    
    if (path_value.type().id() == LogicalTypeId::VARCHAR) {
        // Single path (string)
        string path = path_value.GetValue<string>();
        
        if (path.empty()) {
            throw IOException("Empty file path provided");
        }
        
        // Handle glob patterns
        if (path.find('*') != string::npos || path.find('?') != string::npos) {
            auto globbed_files = fs.Glob(path, recursive ? GlobFlags::GLOB_RECURSE : GlobFlags::GLOB_DEFAULT);
            for (auto &file : globbed_files) {
                // Skip directories
                if (!fs.DirectoryExists(file)) {
                    result.push_back(file);
                }
            }
        } else if (fs.FileExists(path)) {
            // Single file
            result.push_back(path);
        } else if (fs.DirectoryExists(path)) {
            // Directory - look for .yaml and .yml files
            vector<string> extensions = {".yaml", ".yml"};
            for (const auto &ext : extensions) {
                string glob_pattern = path;
                if (glob_pattern.back() != '/' && glob_pattern.back() != '\\') {
                    glob_pattern += '/';
                }
                glob_pattern += "*" + ext;
                
                auto files = fs.Glob(glob_pattern, recursive ? GlobFlags::GLOB_RECURSE : GlobFlags::GLOB_DEFAULT);
                for (auto &file : files) {
                    if (!fs.DirectoryExists(file)) {
                        result.push_back(file);
                    }
                }
            }
            
            if (result.empty()) {
                throw IOException("No YAML files found in directory: " + path);
            }
        } else {
            throw IOException("File or directory does not exist: " + path);
        }
    } else if (path_value.type().id() == LogicalTypeId::LIST) {
        // List of paths
        auto &path_list = ListValue::GetChildren(path_value);
        
        if (path_list.empty()) {
            throw IOException("Empty list of file paths provided");
        }
        
        for (const auto &path_item : path_list) {
            if (path_item.type().id() != LogicalTypeId::VARCHAR) {
                throw IOException("File path must be a string, got: " + path_item.ToString());
            }
            
            string path = path_item.GetValue<string>();
            
            if (path.empty()) {
                throw IOException("Empty file path in list");
            }
            
            // Process each path in the list
            vector<string> files = GetFilesToProcess(context, Value(path), recursive);
            result.insert(result.end(), files.begin(), files.end());
        }
    } else {
        throw IOException("File path must be a string or list of strings, got: " + path_value.ToString());
    }
    
    if (result.empty()) {
        throw IOException("No YAML files found matching the provided path(s)");
    }
    
    return result;
}

// Helper to read a single file and parse it
vector<YAML::Node> YAMLReader::ReadYAMLFile(ClientContext &context, const string &file_path, 
                                          const YAMLReadOptions &options) {
    auto &fs = FileSystem::GetFileSystem(context);
    
    // Check if file exists
    if (!fs.FileExists(file_path)) {
        throw IOException("File does not exist: " + file_path);
    }
    
    auto handle = fs.OpenFile(file_path, FileFlags::FILE_FLAGS_READ);
    idx_t file_size = fs.GetFileSize(*handle);
    
    if (file_size > options.maximum_object_size) {
        throw IOException("YAML file size (" + to_string(file_size) + " bytes) exceeds maximum allowed size (" + 
                          to_string(options.maximum_object_size) + " bytes)");
    }
    
    auto buffer = unique_ptr<char[]>(new char[file_size + 1]);
    fs.Read(*handle, buffer.get(), file_size);
    buffer[file_size] = '\0';
    
    if (options.multi_document) {
        return ParseMultiDocumentYAML(buffer.get(), options.ignore_errors);
    } else {
        try {
            YAML::Node yaml_node = YAML::Load(buffer.get());
            return {yaml_node};
        } catch (const YAML::Exception &e) {
            if (!options.ignore_errors) {
                throw IOException("Error parsing YAML file: " + string(e.what()));
            }
            return {};
        }
    }
}

unique_ptr<FunctionData> YAMLReader::YAMLReadRowsBind(ClientContext &context, 
                                                  TableFunctionBindInput &input,
                                                  vector<LogicalType> &return_types, 
                                                  vector<string> &names) {
    // Validate primary input
    if (input.inputs.empty()) {
        throw BinderException("read_yaml requires a file path parameter");
    }
    
    // Get the file path value (string or list)
    auto path_value = input.inputs[0];
    
    YAMLReadOptions options;
    
    // Parse optional parameters
    if (input.named_parameters.count("auto_detect")) {
        options.auto_detect_types = input.named_parameters["auto_detect"].GetValue<bool>();
    }
    if (input.named_parameters.count("ignore_errors")) {
        options.ignore_errors = input.named_parameters["ignore_errors"].GetValue<bool>();
    }
    if (input.named_parameters.count("maximum_object_size")) {
        options.maximum_object_size = input.named_parameters["maximum_object_size"].GetValue<int64_t>();
        if (options.maximum_object_size <= 0) {
            throw BinderException("maximum_object_size must be a positive integer");
        }
    }
    if (input.named_parameters.count("multi_document")) {
        options.multi_document = input.named_parameters["multi_document"].GetValue<bool>();
    }
    if (input.named_parameters.count("expand_root_sequence")) {
        options.expand_root_sequence = input.named_parameters["expand_root_sequence"].GetValue<bool>();
    }
    bool recursive = false;
    if (input.named_parameters.count("recursive")) {
        recursive = input.named_parameters["recursive"].GetValue<bool>();
    }
    
    // Create bind data with the original path value
    auto result = make_uniq<YAMLReadRowsBindData>(path_value, options);
    
    // Get files using path value
    vector<string> files;
    try {
        files = GetFilesToProcess(context, path_value, recursive);
    } catch (const IOException &e) {
        if (!options.ignore_errors) {
            throw e;
        }
        // With ignore_errors=true, we continue with empty file list
    }
    
    // Vector to store all the row data items (documents or elements)
    vector<YAML::Node> row_nodes;
    
    // Read and process all files
    for (const auto& f : files) {
        try {
            auto docs = ReadYAMLFile(context, f, options);
            auto file_nodes = ExtractRowNodes(docs, options.expand_root_sequence);
            
            // Add nodes from this file
            row_nodes.insert(row_nodes.end(), file_nodes.begin(), file_nodes.end());
        } catch (const std::exception &e) {
            if (!options.ignore_errors) {
                throw IOException("Error processing YAML file '" + f + "': " + string(e.what()));
            }
            // With ignore_errors=true, we allow continuing with other files
        }
    }
    
    // Store the processed row nodes
    result->yaml_docs = row_nodes;
    
    // Extract schema from all row nodes
    unordered_map<string, LogicalType> column_types;
    
    // Process each row node to build the schema
    for (auto &node : result->yaml_docs) {
        // Process each top-level key as a potential column
        for (auto it = node.begin(); it != node.end(); ++it) {
            std::string key = it->first.Scalar();
            YAML::Node value = it->second;
            
            // Detect the type of this value
            LogicalType value_type;
            if (options.auto_detect_types) {
                value_type = DetectYAMLType(value);
            } else {
                value_type = LogicalType::VARCHAR;
            }
            
            // If we already have this column, reconcile the types
            if (column_types.count(key)) {
                if (column_types[key].id() != value_type.id()) {
                    column_types[key] = LogicalType::VARCHAR;
                }
            } else {
                column_types[key] = value_type;
            }
        }
    }
    
    // Build the schema
    for (auto &entry : column_types) {
        names.push_back(entry.first);
        return_types.push_back(entry.second);
    }
    
    // If no columns were found, handle special cases
    if (names.empty()) {
        if (options.ignore_errors) {
            // Return a dummy column for empty results
            names.emplace_back("yaml");
            return_types.emplace_back(LogicalType::STRUCT({})); // Empty struct
        } else if (!result->yaml_docs.empty()) {
            // This could happen with non-map documents without expand_root_sequence
            // Add a fallback value column
            names.emplace_back("value");
            if (options.auto_detect_types) {
                return_types.emplace_back(DetectYAMLType(result->yaml_docs[0]));
            } else {
                return_types.emplace_back(LogicalType::VARCHAR);
            }
        } else {
            // No data and no errors to ignore - just return an empty result
            names.emplace_back("yaml");
            return_types.emplace_back(LogicalType::STRUCT({}));
        }
    }
    
    // Save the schema
    result->names = names;
    result->types = return_types;
    
    return std::move(result);
}

unique_ptr<FunctionData> YAMLReader::YAMLReadBind(ClientContext &context, 
                                               TableFunctionBindInput &input,
                                               vector<LogicalType> &return_types, 
                                               vector<string> &names) {
    // Get the file path value (string or list)
    auto path_value = input.inputs[0];
    
    YAMLReadOptions options;

    // Parse optional parameters
    if (input.named_parameters.count("auto_detect")) {
        options.auto_detect_types = input.named_parameters["auto_detect"].GetValue<bool>();
    }
    if (input.named_parameters.count("ignore_errors")) {
        options.ignore_errors = input.named_parameters["ignore_errors"].GetValue<bool>();
    }
    if (input.named_parameters.count("maximum_object_size")) {
        options.maximum_object_size = input.named_parameters["maximum_object_size"].GetValue<int64_t>();
    }
    if (input.named_parameters.count("multi_document")) {
        options.multi_document = input.named_parameters["multi_document"].GetValue<bool>();
    }
    bool recursive = false;
    if (input.named_parameters.count("recursive")) {
        recursive = input.named_parameters["recursive"].GetValue<bool>();
    }

    // Create bind data with the original path value
    auto result = make_uniq<YAMLReadBindData>(path_value, options);

    // Get files using path value
    vector<string> files;
    try {
        files = GetFilesToProcess(context, path_value, recursive);
    } catch (const IOException &e) {
        if (!options.ignore_errors) {
            throw e;
        }
        // With ignore_errors=true, we continue with empty file list
    }
    
    // Vector to store all YAML documents
    vector<YAML::Node> all_docs;
    
    // Read and process all files
    for (const auto& f : files) {
        try {
            auto docs = ReadYAMLFile(context, f, options);
            all_docs.insert(all_docs.end(), docs.begin(), docs.end());
        } catch (const std::exception &e) {
            if (!options.ignore_errors) {
                throw IOException("Error processing YAML file '" + f + "': " + string(e.what()));
            }
            // With ignore_errors=true, we allow continuing with other files
        }
    }
    
    // Store all documents
    result->yaml_docs = all_docs;

    if (result->yaml_docs.empty()) {
        // Empty result
        names.emplace_back("yaml");
        return_types.emplace_back(LogicalType::VARCHAR);
        return std::move(result);
    }

    // Auto-detect columns from first document
    if (options.auto_detect_types) {
        // For each document, we create a column with the document structure
        names.emplace_back("yaml");
        auto doc_type = DetectYAMLType(result->yaml_docs[0]);
        return_types.emplace_back(doc_type);
    } else {
        // If not auto-detecting, just use VARCHAR for the whole document
        names.emplace_back("yaml");
        return_types.emplace_back(LogicalType::VARCHAR);
    }

    // Save column info
    result->names = names;
    result->types = return_types;

    return std::move(result);
}

// Read functions

void YAMLReader::YAMLReadRowsFunction(ClientContext &context, TableFunctionInput &data_p, 
                                   DataChunk &output) {
    auto &bind_data = (YAMLReadRowsBindData &)*data_p.bind_data;
    
    // If we've processed all rows, we're done
    if (bind_data.current_doc >= bind_data.yaml_docs.size()) {
        output.SetCardinality(0);
        return;
    }
    
    // Process up to STANDARD_VECTOR_SIZE rows at a time
    idx_t count = 0;
    idx_t max_count = std::min((idx_t)STANDARD_VECTOR_SIZE, bind_data.yaml_docs.size() - bind_data.current_doc);
    
    // Set up the output chunk
    output.Reset();
    
    // Special case: if we have a dummy column due to ignore_errors=true, just return empty result
    if (bind_data.names.size() == 1 && 
        (bind_data.names[0] == "yaml" && bind_data.types[0].id() == LogicalTypeId::STRUCT && 
         StructType::GetChildTypes(bind_data.types[0]).empty())) {
        // Just return empty result for dummy columns with no data
        output.SetCardinality(0);
        bind_data.current_doc = bind_data.yaml_docs.size(); // Mark as completed
        return;
    }
    
    // Handle value column specially (non-map documents)
    if (bind_data.names.size() == 1 && bind_data.names[0] == "value") {
        for (idx_t i = 0; i < max_count; i++) {
            // Get the current YAML node
            YAML::Node node = bind_data.yaml_docs[bind_data.current_doc + i];
            
            // Convert to DuckDB value
            Value val = YAMLNodeToValue(node, bind_data.types[0]);
            
            // Add to output
            output.SetValue(0, count, val);
            count++;
        }
    } else {
        // Normal case - process map documents
        for (idx_t i = 0; i < max_count; i++) {
            // Get the current YAML node
            YAML::Node node = bind_data.yaml_docs[bind_data.current_doc + i];
            
            // Process each column
            for (idx_t col_idx = 0; col_idx < bind_data.names.size(); col_idx++) {
                string &name = bind_data.names[col_idx];
                LogicalType &type = bind_data.types[col_idx];
                
                // Get the value for this column
                YAML::Node value = node[name];
                
                // Convert to DuckDB value
                Value duckdb_value;
                if (value) {
                    duckdb_value = YAMLNodeToValue(value, type);
                } else {
                    duckdb_value = Value(type); // NULL value
                }
                
                // Add to output
                output.SetValue(col_idx, count, duckdb_value);
            }
            count++;
        }
    }
    
    // Update current row
    bind_data.current_doc += count;
    
    // Set the cardinality
    output.SetCardinality(count);
}

void YAMLReader::YAMLReadFunction(ClientContext &context, TableFunctionInput &data_p, 
                               DataChunk &output) {
    auto &bind_data = (YAMLReadBindData &)*data_p.bind_data;

    // If we've processed all rows, we're done
    if (bind_data.current_row >= bind_data.yaml_docs.size()) {
        output.SetCardinality(0);
        return;
    }

    // Process up to STANDARD_VECTOR_SIZE rows at a time
    idx_t count = 0;
    idx_t max_count = std::min((idx_t)STANDARD_VECTOR_SIZE, bind_data.yaml_docs.size() - bind_data.current_row);

    // Set up the output chunk
    output.Reset();

    // Fill the output
    for (idx_t i = 0; i < max_count; i++) {
        // Get the current YAML node
        YAML::Node node = bind_data.yaml_docs[bind_data.current_row + i];

        // Convert to DuckDB value
        Value val = YAMLNodeToValue(node, bind_data.types[0]);

        // Add to output
        output.SetValue(0, count, val);
        count++;
    }

    // Update current row
    bind_data.current_row += count;

    // Set the cardinality
    output.SetCardinality(count);
}

void YAMLReader::RegisterFunction(DatabaseInstance &db) {
    // Create read_yaml table function
    TableFunction read_yaml("read_yaml", {LogicalType::ANY}, YAMLReadRowsFunction, YAMLReadRowsBind);
    
    // Add optional named parameters
    read_yaml.named_parameters["auto_detect"] = LogicalType::BOOLEAN;
    read_yaml.named_parameters["ignore_errors"] = LogicalType::BOOLEAN;
    read_yaml.named_parameters["maximum_object_size"] = LogicalType::BIGINT;
    read_yaml.named_parameters["multi_document"] = LogicalType::BOOLEAN;
    read_yaml.named_parameters["expand_root_sequence"] = LogicalType::BOOLEAN;
    read_yaml.named_parameters["recursive"] = LogicalType::BOOLEAN;
    
    // Register the function
    ExtensionUtil::RegisterFunction(db, read_yaml);

    // Register the object-based reader 
    TableFunction read_yaml_objects("read_yaml_objects", {LogicalType::ANY}, YAMLReadFunction, YAMLReadBind);
    read_yaml_objects.named_parameters["auto_detect"] = LogicalType::BOOLEAN;
    read_yaml_objects.named_parameters["ignore_errors"] = LogicalType::BOOLEAN;
    read_yaml_objects.named_parameters["maximum_object_size"] = LogicalType::BIGINT;
    read_yaml_objects.named_parameters["multi_document"] = LogicalType::BOOLEAN;
    read_yaml_objects.named_parameters["recursive"] = LogicalType::BOOLEAN;
    ExtensionUtil::RegisterFunction(db, read_yaml_objects);
}

} // namespace duckdb
